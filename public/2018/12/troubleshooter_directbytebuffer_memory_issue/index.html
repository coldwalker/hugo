<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.124.1">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="https://coldwalker.github.io/css/search.css" />
    <title>DirectByteBuffer堆外内存溢出问题排查 - 凛冬夜行</title>
    
<meta name="description" content="前情提要 最近线上一个图片服务在使用ehcache的diskcache替代旧版“自实现”的磁盘缓存时，发生了java进程常驻内存暴涨导致部署机">

<meta property="og:title" content="DirectByteBuffer堆外内存溢出问题排查 - 凛冬夜行">
<meta property="og:type" content="article">
<meta property="og:url" content="https://coldwalker.github.io/2018/12/troubleshooter_directbytebuffer_memory_issue/">
<meta property="og:image" content="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/thumb.jpg">
<meta property="og:site_name" content="凛冬夜行">
<meta property="og:description" content="前情提要 最近线上一个图片服务在使用ehcache的diskcache替代旧版“自实现”的磁盘缓存时，发生了java进程常驻内存暴涨导致部署机">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="凛冬夜行">
<meta name="twitter:url" content="https://coldwalker.github.io/2018/12/troubleshooter_directbytebuffer_memory_issue/">
<meta name="twitter:title" content="DirectByteBuffer堆外内存溢出问题排查 - 凛冬夜行">
<meta name="twitter:description" content="前情提要 最近线上一个图片服务在使用ehcache的diskcache替代旧版“自实现”的磁盘缓存时，发生了java进程常驻内存暴涨导致部署机">
<meta name="twitter:image" content="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/thumb.jpg">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https:\/\/coldwalker.github.io\/"
    },
    "headline": "DirectByteBuffer堆外内存溢出问题排查 - 凛冬夜行",
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/coldwalker.github.io\/images\/troubleshooter_directbytebuffer_memory_issue\/thumb.jpg",
      "height": 800,
      "width": 800
    },
    "datePublished": "2018-12-03T11:30:00JST",
    "dateModified": "2018-12-03T11:30:00JST",
    "author": {
      "@type": "Person",
      "name": "凛冬夜行"
    },
    "publisher": {
      "@type": "Organization",
      "name": "凛冬夜行",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/coldwalker.github.io\/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "前情提要 最近线上一个图片服务在使用ehcache的diskcache替代旧版“自实现”的磁盘缓存时，发生了java进程常驻内存暴涨导致部署机"
  }
</script>


    <link href="https://coldwalker.github.io/css/styles.css" rel="stylesheet">
    

  </head>

  <body>
    
        
            
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-116113253-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

        
        
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?f13b34958e759c7a5400b5cdf455f21c";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>
        
   
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://coldwalker.github.io/">凛冬夜行</a>
          </div>

          
          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="https://coldwalker.github.io/2018/03/about/">about Me</a></li>
              
              
              
              <li>
                  <a href="#modalSearch" data-toggle="modal" data-target="#modalSearch" style="outline: none;">
                    <span class="hidden-sm hidden-md hidden-lg"></span> <span id="searchGlyph" class="glyphicon glyphicon-search"></span>
                  </a>
             </li>
                
            </ul>
            
          </div>
          

        </div>
    
         <div id="modalSearch" class="modal fade" role="dialog">
            <div class="modal-dialog">
              <div class="modal-content">
                <div class="modal-header">
                  <button type="button" class="close" data-dismiss="modal">&times;</button>
                  <h4 class="modal-title">Search coldwalker.github.io</h4>
                </div>
                <div class="modal-body">
                    <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..." name="search" autocomplete="off" />
    <svg class="aa-input-icon" viewBox="654 -372 1664 1664">
        <path d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
    </svg>
</div>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
var client = algoliasearch("YP0YEWOT73", "546beefe9023181eb1827f484030b66b");
var index = client.initIndex('coldwalker-blog');
autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 8}),
    displayKey: 'name',
    templates: {
        suggestion: function(suggestion) {
            console.log(suggestion);
            var postDate = new Date(suggestion.date);
            var postYear = postDate.getFullYear();
            var postMonth = postDate.getMonth() + 1;
            if(postMonth < 10)
            postMonth = "0" + postMonth;
            var title = suggestion.objectID.split("/", 2)[1];            
            return '<span>' + '<a href="https://coldwalker.github.io/' + postYear + "/" + postMonth + "/" + title + '">' +
            suggestion._highlightResult.title.value + '</a></span>';
        }
    }
});
</script>

                </div>
                <div class="modal-footer">
                  <button type="button" class="btn btn-default" data-dismiss="modal">close</button>
                </div>
              </div>
            </div>
        </div>

      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-9">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="https://coldwalker.github.io/"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="https://coldwalker.github.io/post/" itemprop="url"><span itemprop="title">post</span></a></li>
        
        <li class="active">DirectByteBuffer堆外内存溢出问题排查</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <ul class="p-facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-12-03T11:30:00JST">2018-12-03</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://coldwalker.github.io/post/">post</a></li>
      
    </ul>

    <h1 class="title">DirectByteBuffer堆外内存溢出问题排查</h1>
  </header>

  <div class="thumb" style="background-image: url(https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/thumb.jpg);"></div>

  <div class="article-body"><h3 id="前情提要">前情提要</h3>
<p>最近线上一个图片服务在使用ehcache的diskcache替代旧版“自实现”的磁盘缓存时，发生了java进程常驻内存暴涨导致部署机器内存耗尽的问题。</p>
<p><em>具体现象是：机器内存32G，堆内存设置Xmx 20G，服务启动后发现java进程使用的常驻内存（RES）逐渐上涨，几天后整体RES达到了惊人的29G（升级ehcache前大概RES峰值在23G），导致系统开始吃swap，服务性能下降严重。</em></p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/7F005065-9886-42D7-B474-6A221A4A20CB.png" alt="66458b4ec3bec765a54684e358df147c.png"></p>
<p>因为以前也分析过一个“由于glibc的ptmalloc2内存分配机制缺陷”导致堆外内存溢出的问题（具体可移步<a href="https://coldwalker.github.io/2018/08//troubleshooter_native_memory_increase/">Java堆外内存增长问题排查Case</a>)，但出问题的业务已经优化过arena内存池参数，排除了这一块的嫌疑，因此具体原因还需要另做分析。</p>
<h3 id="排查过程">排查过程</h3>
<h4 id="1-确认堆内内存是否使用正常">1. 确认堆内内存是否使用正常</h4>
<h5 id="gc情况分析">GC情况分析</h5>
<p>先通过GC日志分析堆内存是否存在问题。GC日志看出现问题时年轻代的GC没有问题，很正常。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/B62D9D5E-2EC1-4694-86CC-D6E8DF28F3DE.png" alt="3ab5326dab9ac3efdae630779b77dc1f.png"></p>
<p>年老代GC除了回收频率较快（配置问题，这里暂且不表），也没有什么异常情况。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/7847C65D-20C8-4557-9E19-FF953C2292B5.png" alt="b37822d351c86f4f55234834ab9d64ff.png"></p>
<p>另外，出问题时整体也没有Full GC、提升失败（promotion failedl）、并发模式失败（concurrent mode failure）这些异常情况。</p>
<h5 id="堆dump进一步确认">堆dump进一步确认</h5>
<p>为进一步确认堆内存是否正常，把出问题时的堆dump下来分析。</p>
<pre tabindex="0"><code>jmap -dump:file=199.bin 12
</code></pre><p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/09FDB2E9-0C49-4E8C-A9CD-BA72ED78E767.png" alt="ada24ba2637eee9be1ac3a4eccfbcb9f.png"></p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/CCA026D3-B8F1-4901-ABC6-6A48E423E91F.png" alt="bc9117edb78cf7632ff2d91a01e4dad4.png"></p>
<p>可以看到基本上都是ehcache使用的堆内存，使用量和业务里配置的也都一致，dominator_tree上看其他对象都比较小，基本没有嫌疑。</p>
<p><em>这里基本确认了堆内存使用正常。</em></p>
<h4 id="2-查看java进程占用内存的具体情况">2. 查看java进程占用内存的具体情况</h4>
<p>由于top命令只能看到当前进程使用的整体情况，所以这里使用pmap来详细列出内存使用的情况，因为我们关心的是实际使用的物理内存而不是进程映射的虚拟内存，所以这里使用-x来显示pmap的扩展格式才能看到常驻内存RES。</p>
<p><em>PS： pmap命令的输出内容来自于/proc/[pid]/maps和/proc/[pid]/smaps这两个文件，maps文件包含了每一段内存的大概描述，smaps里包含了具体每段的详细信息。</em></p>
<pre tabindex="0"><code>pmap -x 12 | sort -rn -k3 | head -30
</code></pre><p>这里按照RES的占用大小来进行排序，取占用Top 30的内存段。</p>
<p>发现较多的几十兆的大内存块，和正常的未灰度的机器的内存使用比，有比较大的嫌疑。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/38E28E42-7B54-4524-8F8F-0536F71E5546.png" alt="2b218f828d1a0cd49461a2460128d6e6.png"></p>
<hr>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/FF283501-F6E0-475C-893A-4C3DAF0CC4E8.png" alt="7f6ee22f1bebde53f75449428a01c432.png"></p>
<p>找一块比较有嫌疑的内存段dump下来看一下里面的具体内容，这里选取了有问题的进程的46684K的那一段。</p>
<pre tabindex="0"><code>gdb --batch --pid 12 -ex &#34;dump memory 199.dump 0x7facdd269000 0x7facdd269000+46684000&#34;
hexdump -C 199.dump | less
</code></pre><p>发现貌似都是一些非文本的二进制数据，具体分析不出来内容，基本放弃直接通过内存段内容来定位问题了。</p>
<h4 id="3-nmt跟踪jvm本地内存的使用情况">3. NMT跟踪JVM本地内存的使用情况</h4>
<p>在之前的文章有提到过，Native Memory Tracking是JDK7U40引入的HotSpot新特性，可用于监控JVM原生内存的使用，java进程启动时指定开启NMT（有一定的性能损耗），输出级别可以设置为“summary”或“detail”级别，开启后，通过jcmd可以访问收集到的数据。JVM启动时加上：</p>
<pre tabindex="0"><code>-XX:NativeMemoryTracking=summary 或者 -XX:NativeMemoryTracking=detail
</code></pre><p>具体NMT的使用可以在<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/nmt-8.html">NMT使用说明</a>和<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html#BABIIIAC">使用NMT排查问题</a>里查看，NMT支持summary和detail级别的track，另外还支持基于baseline的比对track。在这个case里由于堆外内存是缓慢增长的，因此比较好的方式是采用baseline的比对方式来排查，这样方便看增长期间具体堆外内存的变化情况。</p>
<p><em>具体操作：</em></p>
<ul>
<li>先建立跟踪基线，并记录当时的内存使用情况，放置一段时间。</li>
</ul>
<pre tabindex="0"><code>jcmd 12 VM.native_memory baseline
</code></pre><p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/DD5CE425-29ED-4169-9B24-BE59AEE50B03.png" alt="389c8f6cf2ede156d79f0861a38094e9.png"></p>
<ul>
<li>运行一段时间后，和基线做diff，看下堆外内存的具体变化情况。</li>
</ul>
<pre tabindex="0"><code>jcmd 12 VM.native_memory summary.diff
或者
jcmd 12 VM.native_memory detail.diff
</code></pre><p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/7F3B2B00-0424-4358-A2C0-187143F42FFF.png" alt="8550b6c74d498cc0e75a0e2e94508968.png"></p>
<p>从图可知，java堆占用增长了6.8G，整体内存（RES）增长 8.1G，非堆内存增加大概1.3G，其中绝大部分来自于Internal部分的增长，按照oracle官方的解释，Internal部分的内存主要用于：
<em>Memory that does not fit the previous categories, such as the memory used by the command line parser, JVMTI, properties and so on.</em>
值得注意的是，DirectByteBuffer的内存使用实际上也属于Internal的类别。因为像JVMTI和properties这些项目都没有用到，因此把重点锁定到DirectByteBuffer这个容易出问题的对象上。</p>
<h4 id="4-jmcjava-mission-control查看directbytebuffer的占用">4. JMC（Java Mission Control）查看DirectByteBuffer的占用</h4>
<p>JMC作为JVisualVM的替代工具，功能强大，而且免费。非代码植入的采样机制对系统性能影响也比较小，很多公司在线上也是开着JMC的。这里不展开，有兴趣的可自行查询。</p>
<ul>
<li>第一步，JVM开启jmx。
JVM启动时加上：</li>
</ul>
<pre tabindex="0"><code> -Dcom.sun.management.jmxremote.port=7001 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=your ip
</code></pre><ul>
<li>第二步，本机打开JMC工具，通过jmx远程连接，并启动JMX控制台。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/C8ECBDB8-9A35-42C4-B72E-8CA5347E7681.png" alt="dc82f4206a3d720fae11a37100096b8d.png"></li>
</ul>
<hr>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/6D89A1ED-373C-4C61-BEFA-17A214F2D5B2.png" alt="024bfdf085aa720978b2148739f96d47.png"></p>
<ul>
<li>第三步，通过MBean浏览器筛选出DirectByteBuffer的跟踪器。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/1FA50C62-9BD5-47D3-9D3C-8733654AC7B4.png" alt="9a03d2c6052c67da7fb82147b811dcd4.png"></li>
</ul>
<p>果然，在只有813个对象的情况下，DirecByteBuffer的使用居然达到了2.4G，平均每个对象达到了3M。观察一段时间，发现DBB的增长和NMT里Internal部分的增长基本一致，和pmap里增多的几十M的内存段的总和也能对上。</p>
<ul>
<li>第四步，比对正常机器的DBB。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/FFA5B19A-2A16-491A-A610-A39AE017F9A1.png" alt="9a2da78abb4c57901d26a50af1329afd.png"></li>
</ul>
<p>发现正常机器DBB的占用内存量比问题机器的占用量小很多，且基本保持稳定，有问题的机器的DBB内存占用量还在持续上涨，<!-- raw HTML omitted -->到这里基本可以确定是由于DBB的内存占用导致的问题<!-- raw HTML omitted -->。</p>
<h4 id="5-分析directbytebuffer的使用情况">5. 分析DirectByteBuffer的使用情况</h4>
<p>定位到DBB的问题后，接下来需要确定具体是哪里导致DBB的内存占用量飙涨。这里先普及一下DirectByteBuffer。</p>
<p>DirectByteBuffer是JDK提供的一个缓冲池类，通常被用于通信框架中，如netty，mina等。DirectByteBuffer在创建的时候会通过Unsafe的native方法来直接使用malloc分配一块堆外内存。注意：由于这块内存真正的分配并不在Java堆中（堆中只有一个很小的对象引用，因此也被称为冰山对象），这种方式能减轻GC的压力；另外，对于堆内对象，如果要进行IO操作（Socket、文件读写）时，需要先把对象拷贝一份到堆外直接内存，然后再写入Socket或者文件，但由于DirectByteBuffer本身就是在堆外内存分配，因此进行IO时不需要再做那一次从堆内拷贝到堆外的操作，性能上会更好。值得注意的是：由于java堆内存是预申请好的，对于堆内对象的内存分配性能很好，相比较，DirectByteBuffer这种用时才通过malloc、free向操作系统临时申请内存的方式性能会慢一些，因此类似Netty这种IO框架，会对DirectByteBuffer进行池化管理，多次复用，避免每次都需要向操作系统申请和释放内存的开销。</p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/AEFE1D50-57B6-4C3E-A882-81FC54C58074.png" alt="426aadda4f909523554ad54cc712da8b.png"></p>
<h5 id="directbytebuffer的内存分配和回收">DirectByteBuffer的内存分配和回收</h5>
<p><em>基本流程：</em> 先通过Bits.reserveMemory申请内存额度，Bits类维护了一个全局的totalCapacity用于记录已分配的全部DirectByteBuffer的总大小，jVM提供了一个-XX:MaxDirectMemorySize的设置（默认等于Xmx的大小），用来限制可以分配的总的DirectByteBuffer的内存大小，如果没有超限，就调用native的Unsafe.allocateMemory去执行真正的内存分配（实际就是调用malloc)；如果额度已满，就先调用tryHandlePendingReference尝试进行非阻塞的堆外内存回收，如果还是分配不到，就会通过System.gc进行一次Full GC，再尝试几次分配，如果还是不成功就抛出一个DirectByteBuffer的OOME。</p>
<p>每个DirectByteBuffer在生成时会绑定一个Cleaner对象，这个Cleaner对象是一个PhantomReference（具体啥是幻象应用请自行搜索），当JVM GC时发现那些除了Cleaner幻象引用外已没有其他引用的DirectByteBuffer时，就会把这些Cleaner对象放到Reference这个类的pending列表里，Reference类维护了一条ReferenceHandler的高优先级线程，这条线程会不断去轮询待处理的pending列表，如果是Cleaner对象就调用这个对象的clean方法进行清理，clean方法里其实是调用初始化Cleaner时绑定的Deallocator间接使用unsafe.freeMemory来进行堆外内存的释放和Bits里全局堆外内存使用量的更新。</p>
<p><!-- raw HTML omitted -->PS：实际并不存在一个pending列表，JVM将要被处理的Cleaner对象被封装成一个链表，通过Reference类中的discovered进行排队，ReferenceHandler线程只需要不停地拿到pending，然后再通过discovered不断地拿到下一个对象赋值给pending即可，直到取到了最有一个。因为这个pending对象，两个线程都可能访问,因此需要加锁处理。<!-- raw HTML omitted --></p>
<p><em>先看下分配的代码：</em></p>
<p>DirectByteBuffer的构造函数，先通过Bits工具类根据维护的总堆外内存情况来进行预分配，然后再预分配OK的情况下使用unsafe来进行真正的堆外内存分配。</p>
<pre tabindex="0"><code>DirectByteBuffer(int cap) {                   // package-private
        super(-1, 0, cap, cap);
        boolean pa = VM.isDirectMemoryPageAligned();
        int ps = Bits.pageSize();
        long size = Math.max(1L, (long)cap + (pa ? ps : 0));
        Bits.reserveMemory(size, cap);

        long base = 0;
        try {
            base = unsafe.allocateMemory(size);
        } catch (OutOfMemoryError x) {
            Bits.unreserveMemory(size, cap);
            throw x;
        }
        unsafe.setMemory(base, size, (byte) 0);
        if (pa &amp;&amp; (base % ps != 0)) {
            // Round up to page boundary
            address = base + ps - (base &amp; (ps - 1));
        } else {
            address = base;
        }
        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));
        att = null;
    }
</code></pre><hr>
<p><em>Bits工具类预分配逻辑:</em> 先判断是否申请的内存大小超额，如未超额则正常放行返回，否则先通过tryHandlePendingReference（实际调用的Reference#tryHandlePending(false)）尝试以非堵塞的方式将GC后除了Cleaner外没有其他引用的DirectByteBuffer的堆外内存释放掉。注意这里会一直尝试去释放，直到成功或者在tryHandlePending内部抛出了OOME后才被终止。然后这时会通过System.gc触发一次Full GC，通过Full GC遍历引用时来将更多的除Cleaner外没有其他引用的DirectByteBuffer通过ReferenceHandler来进行堆外内存的释放，但由于System.gc并不能够保证马上触发Full GC，因此这里会进行最多9次尝试，看是否有足够的可用堆外内存来分配堆外内存。并且每次尝试后，如果失败都指数级sleep，给JVM足够的时间去完成full gc操作。如果9次尝试后依旧没有足够的可用堆外内存来分配本次堆外内存，则抛出OutOfMemoryError(&ldquo;Direct buffer memory”)异常。</p>
<pre tabindex="0"><code>static void reserveMemory(long size, int cap) {
        if (!memoryLimitSet &amp;&amp; VM.isBooted()) {
            maxMemory = VM.maxDirectMemory();
            memoryLimitSet = true;
        }

        // optimist!
        if (tryReserveMemory(size, cap)) {
            return;
        }

        final JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();

        // retry while helping enqueue pending Reference objects
        // which includes executing pending Cleaner(s) which includes
        // Cleaner(s) that free direct buffer memory
        while (jlra.tryHandlePendingReference()) {
            if (tryReserve在ory(size, cap)) {
                return;
            }
        }

        // trigger VM&#39;s Reference processing
        System.gc();

        // a retry loop with exponential back-off delays
        // (this gives VM some time to do it&#39;s job)
        boolean interrupted = false;
        try {
            long sleepTime = 1;
            int sleeps = 0;
            while (true) {
                if (tryReserveMemory(size, cap)) {
                    return;
                }
                if (sleeps &gt;= MAX_SLEEPS) {
                    break;
                }
                if (!jlra.tryHandlePendingReference()) {
                    try {
                        Thread.sleep(sleepTime);
                        sleepTime &lt;&lt;= 1;
                        sleeps++;
                    } catch (InterruptedException e) {
                        interrupted = true;
                    }
                }
            }

            // no luck
            throw new OutOfMemoryError(&#34;Direct buffer memory&#34;);

        } finally {
            if (interrupted) {
                // don&#39;t swallow interrupts
                Thread.currentThread().interrupt();
            }
        }
    }
    
</code></pre><hr>
<p>判断是否超额的相关方法实现:</p>
<pre tabindex="0"><code>    private static boolean tryReserveMemory(long size, int cap) {
        // -XX:MaxDirectMemorySize limits the total capacity rather than the
        // actual memory usage, which will differ when buffers are page
        // aligned.
        long totalCap;
        while (cap &lt;= maxMemory - (totalCap = totalCapacity.get())) {
            if (totalCapacity.compareAndSet(totalCap, totalCap + cap)) {
                reservedMemory.addAndGet(size);
                count.incrementAndGet();
                return true;
            }
        }

        return false;
    }
</code></pre><hr>
<p>Cleaner的抽象父类Reference几个重要的变量和非常核心的tryHandlePending方法:</p>
<pre tabindex="0"><code>  /* When active:   next element in a discovered reference list maintained by GC (or this if last)
     *     pending:   next element in the pending list (or null if last)
     *   otherwise:   NULL
     */
    transient private Reference&lt;T&gt; discovered;  /* used by VM */


    /* Object used to synchronize with the garbage collector.  The collector
     * must acquire this lock at the beginning of each collection cycle.  It is
     * therefore critical that any code holding this lock complete as quickly
     * as possible, allocate no new objects, and avoid calling user code.
     */
    static private class Lock { }
    private static Lock lock = new Lock();


    /* List of References waiting to be enqueued.  The collector adds
     * References to this list, while the Reference-handler thread removes
     * them.  This list is protected by the above lock object. The
     * list uses the discovered field to link its elements.
     */
    private static Reference&lt;Object&gt; pending = null;
  
    /**
     * Try handle pending {@link Reference} if there is one.&lt;p&gt;
     * Return {@code true} as a hint that there might be another
     * {@link Reference} pending or {@code false} when there are no more pending
     * {@link Reference}s at the moment and the program can do some other
     * useful work instead of looping.
     *
     * @param waitForNotify if {@code true} and there was no pending
     *                      {@link Reference}, wait until notified from VM
     *                      or interrupted; if {@code false}, return immediately
     *                      when there is no pending {@link Reference}.
     * @return {@code true} if there was a {@link Reference} pending and it
     *         was processed, or we waited for notification and either got it
     *         or thread was interrupted before being notified;
     *         {@code false} otherwise.
     */
    static boolean tryHandlePending(boolean waitForNotify) {
        Reference&lt;Object&gt; r;
        Cleaner c;
        try {
            synchronized (lock) {
                if (pending != null) {
                    r = pending;
                    // &#39;instanceof&#39; might throw OutOfMemoryError sometimes
                    // so do this before un-linking &#39;r&#39; from the &#39;pending&#39; chain...
                    c = r instanceof Cleaner ? (Cleaner) r : null;
                    // unlink &#39;r&#39; from &#39;pending&#39; chain
                    pending = r.discovered;
                    r.discovered = null;
                } else {
                    // The waiting on the lock may cause an OutOfMemoryError
                    // because it may try to allocate exception objects.
                    if (waitForNotify) {
                        lock.wait();
                    }
                    // retry if waited
                    return waitForNotify;
                }
            }
        } catch (OutOfMemoryError x) {
            // Give other threads CPU time so they hopefully drop some live references
            // and GC reclaims some space.
            // Also prevent CPU intensive spinning in case &#39;r instanceof Cleaner&#39; above
            // persistently throws OOME for some time...
            Thread.yield();
            // retry
            return true;
        } catch (InterruptedException x) {
            // retry
            return true;
        }
        // Fast path for cleaners
        if (c != null) {
            c.clean();
            return true;
        }
        ReferenceQueue&lt;? super Object&gt; q = r.queue;
        if (q != ReferenceQueue.NULL) q.enqueue(r);
        return true;
    }
</code></pre><hr>
<p>Reference类静态代码块中启动的高优先级的ReferenceHandler线程，主要靠它来轮询pending链表进行堆外内存的回收。</p>
<pre tabindex="0"><code>static {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
        Thread handler = new ReferenceHandler(tg, &#34;Reference Handler&#34;);
       /* If there were a special system-only priority greater than
         * MAX_PRIORITY, it would be used here
         */
        handler.setPriority(Thread.MAX_PRIORITY);
        handler.setDaemon(true);
        handler.start();
        // provide access in SharedSecrets
        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
            @Override
            public boolean tryHandlePendingReference() {
                return tryHandlePending(false);
            }
        });
    }
</code></pre><hr>
<p>Cleaner类几个核心变量：静态的first，私有的next，prev，一个没啥用的dummyQueue。first、next、prev主要用来维护一个双向链表，用来保证他们引用的referent被回收前自身不会被GC掉，这也是为啥first需要是static的原因。在Cleaner create的时候会把自己通过add加入到双向链表中，另外在tryHandlePending调用clean进行堆外内存清理时，通过remove方法将自身从双向链表中移除，这样这个没用的Cleaner本身也能被GC掉了。另外ReferenceQueue是作为 JVM GC与上层Reference对象管理之间的一个消息传递方式，它使得我们可以对所监听的对象引用可达发生变化时做一些处理，但在Cleaner里这个dummyQueue没有用，因为在tryHandlePending里如果是Cleaner就调用完它的clean方法后直接返回，不会和这个queue做啥交互，这也是为啥这个queue在Cleaner里叫dummyQueue的原因。</p>
<pre tabindex="0"><code>// Dummy reference queue, needed because the PhantomReference constructor
    // insists that we pass a queue.  Nothing will ever be placed on this queue
    // since the reference handler invokes cleaners explicitly.
    private static final ReferenceQueue&lt;Object&gt; dummyQueue = new ReferenceQueue&lt;&gt;();

    // Doubly-linked list of live cleaners, which prevents the cleaners
    // themselves from being GC&#39;d before their referents
    static private Cleaner first = null;

    private Cleaner
        next = null,
        prev = null;
</code></pre><hr>
<p>Cleaner类创建时传入的Runnable是一个Deallocator对象，该对象底层通unsafe的freeMemory来完成真正的堆外内存清理。</p>
<pre tabindex="0"><code> public static Cleaner create(Object var0, Runnable var1) {
        return var1 == null ? null : add(new Cleaner(var0, var1));
    }
    public void clean() {
        if (remove(this)) {
            try {
                this.thunk.run();
            } catch (final Throwable var2) {
                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
                    public Void run() {
                        if (System.err != null) {
                            (new Error(&#34;Cleaner terminated abnormally&#34;, var2)).printStackTrace();
                        }

                        System.exit(1);
                        return null;
                    }
                });
            }

        }
    }
   
    private static class Deallocator
        implements Runnable
    {
        private static Unsafe unsafe = Unsafe.getUnsafe();

        private long address;
        private long size;
        private int capacity;

        private Deallocator(long address, long size, int capacity) {
            assert (address != 0);
            this.address = address;
            this.size = size;
            this.capacity = capacity;
        }

        public void run() {
            if (address == 0) {
                // Paranoia
                return;
            }
            unsafe.freeMemory(address);
            address = 0;
            Bits.unreserveMemory(size, capacity);
        }

    }
</code></pre><hr>
<p>Unsafe.allocateMemory的C++的Native实现，底层使用的C库的malloc来进行分配。</p>
<pre tabindex="0"><code>    UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))
      UnsafeWrapper(&#34;Unsafe_AllocateMemory&#34;);
      size_t sz = (size_t)size;
      if (sz != (julong)size || size &lt; 0) {
        THROW_0(vmSymbols::java_lang_IllegalArgumentException());
      }
      if (sz == 0) {
        return 0;
      }
      sz = round_to(sz, HeapWordSize);
      void* x = os::malloc(sz, mtInternal);
      if (x == NULL) {
        THROW_0(vmSymbols::java_lang_OutOfMemoryError());
      }
      //Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);
      return addr_to_java(x);
    UNSAFE_END
</code></pre><h4 id="6-确认堆外内存的回收情况">6. 确认堆外内存的回收情况</h4>
<p>了解到DirectByteBuffer的分配和回收机制，正常情况下，一个DirectByteBuffer在使用完并不需要主动释放堆外内存，分配时如果由于超额导致堆外内存不够分配会尝试回收已经空闲的DirectByteBuffer底层的堆外内存，另外那条高优先级的ReferenceHandler线程也会不停将GC识别出来没引用的DirectByteBuffer的堆外内存进行回收。
由于线上并没有MaxDirectMemorySize的设置（默认和Xmx大小一样），因此基本不会触发超额的问题。这里尝试进行一次手动Full GC，看下ReferenceHandler线程能回收多少堆外内存。</p>
<pre tabindex="0"><code>jmap -histo:live pid
</code></pre><p>将线上服务暂停处理，然后手动强制进行Full GC，一段时间后通过JMC发现占用的堆外内存数量和大小居然都没有减少，这个有点意外，因为ReferenceHandler线程是最高优先级的，一般不会出啥问题，只能说明DirectByteBuffer的堆外内存不能被回收是因为除了Cleaner这个幻象引用还有其他引用。</p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/90199E37-2728-4B44-9666-7B6132BAF7E6.png" alt="136018057c2010558d412939cd241098.png"></p>
<hr>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/2C239F52-6666-4C1E-822C-23152DC2FD26.png" alt="564e4178dd1191506b6525d8c5734d51.png"></p>
<p>进一步确认，接着尝试JVM进程启动时设置-XX:MaxDirectMemorySize=800m，查看gc log，发现堆外内存到达800M时，确实抛出了OOME也触发了System GC，但却没有能回收到堆外内存。</p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/DDF4B3BB-8B8D-4D7F-966A-AA595918EBA9.png" alt="4674c21e22010d7926e1da9968b1c367.png"></p>
<hr>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/334BECE0-4AE2-40CB-BD71-83DA0A0DC4B6.png" alt="2a4e4178b9c60ffbef9019645df3224b.png"></p>
<hr>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/53A273C8-238B-4FF5-B317-92F48B2C1224.png" alt="2860ccce57a44eb4b629f50ee79686bb.png"></p>
<h4 id="7-分析不能被回收的directbytebuffer的引用">7. 分析不能被回收的DirectByteBuffer的引用</h4>
<pre tabindex="0"><code>jmap -dump:live,file=199.bin 12
</code></pre><p><!-- raw HTML omitted -->这里堆dump的时候通过live在dump前进行一次Full GC，这样只会保留不能被GC的对象，降低干扰，方便问题排查。然后使用MAT对堆dump进行分析。<!-- raw HTML omitted --></p>
<ul>
<li>OQL过滤出被引用对象大于1个的DirectByteBuffer，并且把持有的堆外内存的实际大小capacity列出来。之所以过滤出被引用对象大于1个是找到除了Cleaner外还有其他引用的DirectByteBuffer。</li>
</ul>
<pre tabindex="0"><code>SELECT k, k.capacity, k.limit FROM java.nio.DirectByteBuffer k WHERE (inbounds(k).size() &gt; 1)
</code></pre><p>将DirectByteBuffer按capacity进行排序，发现最大的DirectByteBuffer占用内存达到了40多M，粗略把这些DirectByteBuffer的capacity累加，基本和增长的堆外内存大小差不多。</p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/1EF96237-D2E1-4190-8C30-25071370BA6B.png" alt="3b25cd9cfe0d0158f94d483d133900ab.png"></p>
<p>通过Merge Shortest Paths to GC ROOTs或者List Objects-&gt;with incoming references看一下这些DirectByteBuffer不能被回收的引用路径，并排除掉幻象引用、弱引用、软引用这些实际可以回收的对象。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/1DE69363-87CC-44EA-936F-B62C47D94DF1.png" alt="2d14ad251f87e209c700ac3ac7980fb4.png"></p>
<p>确认这些不能被回收的DirectByteBuffer是被Tomcat的worker线程的ThreadLocal引用。但没有具体调用栈，看不出什么场景被引用上的，接下来用BTrace来跟踪一下具体DirectByteBuffer申请的调用链路。
<img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/031C43EE-ACAA-4CDF-8B59-45C77055DC21.png" alt="e272ee50f2abb9b5d929a88239bbc34b.png"></p>
<h4 id="8-btrace跟踪directbytebuffer的堆外内存申请路径">8. Btrace跟踪DirectByteBuffer的堆外内存申请路径</h4>
<p>当有申请请求时，通过btrace把线程栈打出来，定位调用源头。btrace的使用方法在这里不细说，可以参考之前写的关于btrace的文章<a href="https://coldwalker.github.io/2018/03//troubleshooter_btrace01/">问题排查利器之-JVM动态追踪工具BTrace</a>。</p>
<pre tabindex="0"><code>import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;

@BTrace
public class TraceDirectAlloc {
    @OnMethod(clazz=&#34;java.nio.Bits&#34;, method=&#34;reserveMemory&#34;)
    public static void printThreadStack() {
        println(&#34;==============thread dump where reserveMemory invoked!&#34;);
        jstack();
    }
}
</code></pre><pre tabindex="0"><code>sh bin/btrace 12 TraceDirectAlloc.java &gt; alloc.log
</code></pre><p>和没有问题的服务的btrace比较，发现较多这种线程栈，看方法名应该是往ehcache磁盘缓存写数据时会用到DirectByteBuffer，进一步分析。</p>
<p><img src="https://coldwalker.github.io/images/troubleshooter_directbytebuffer_memory_issue/66305209-39FE-4169-A1C2-C85E7B53233F.png" alt="c6979b0bec54699c7e1a50cc00fc73b0.png"></p>
<h4 id="9-ehcache的磁盘缓存写文件分析">9. Ehcache的磁盘缓存写文件分析</h4>
<p>当有文件需要暂存到ehcache的磁盘缓存时，使用到了NIO中的FileChannel来读取文件，默认ehcache使用了堆内的HeapByteBuffer来给FileChannel作为读取文件的缓冲，FileChannel读取文件使用的IOUtil的read方法，针对HeapByteBuffer底层还用到一个临时的DirectByteBuffer来和操作系统进行直接的交互。</p>
<p>ehcache使用HeapByteBuffer作为读文件缓冲:</p>
<pre tabindex="0"><code>ByteBuffer readBuffer(long position, int length) {
            try {
                ByteBuffer data = ByteBuffer.allocate(length);

                int read;
                for(int i = 0; data.hasRemaining(); i += read) {
                    read = FileBackedStorageEngine.this.readFromChannel(data, position + (long)i);
                    if (read &lt; 0) {
                        throw new EOFException();
                    }
                }

                return (ByteBuffer)data.rewind();
            } catch (IOException var7) {
                throw new RuntimeException(var7);
            } catch (OutOfMemoryError var8) {
                FileBackedStorageEngine.LOGGER.error(&#34;Failed to allocate direct buffer for FileChannel read.  Consider increasing the -XX:MaxDirectMemorySize property to allow enough space for the FileChannel transfer buffers&#34;);
                throw var8;
            }
        }
</code></pre><p>IOUtil对于HeapByteBuffer实际会用到一个临时的DirectByteBuffer来和操作系统进行交互。</p>
<pre tabindex="0"><code>static int read(FileDescriptor fd, ByteBuffer dst, long position,
                    NativeDispatcher nd)
        throws IOException
    {
        if (dst.isReadOnly())
            throw new IllegalArgumentException(&#34;Read-only buffer&#34;);
        if (dst instanceof DirectBuffer)
            return readIntoNativeBuffer(fd, dst, position, nd);

        // Substitute a native buffer
        ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());
        try {
            int n = readIntoNativeBuffer(fd, bb, position, nd);
            bb.flip();
            if (n &gt; 0)
                dst.put(bb);
            return n;
        } finally {
            Util.offerFirstTemporaryDirectBuffer(bb);
        }
    }
</code></pre><h4 id="10-directbytebuffer泄露根因分析">10. DirectByteBuffer泄露根因分析</h4>
<p><em><!-- raw HTML omitted -->重点来了：<!-- raw HTML omitted --></em> 默认情况下这个临时的DirectByteBuffer会被缓存在一个ThreadLocal的bufferCache里不会释放，每一个bufferCache有一个DirectByteBuffer的数组，每次当前线程需要使用到临时DirectByteBuffer时会取出自己bufferCache里的DirectByteBufferS，选取一个不小于所需size的，如果bufferCache为空或者没有符合的，就会调用Bits重新创建一个，使用完之后再缓存到bufferCache里。这里的问题在于 ：这个bufferCache是ThreadLocal的，意味着极端情况下有N个调用线程就会有N组 bufferCache，就会有N组DirectByteBuffer被缓存起来不被释放，而且不同于在IO时直接使用DirectByteBuffer，这N组DirectByteBuffer连GC时都不会回收。我们的文件服务在读写ehcache的磁盘缓存时直接使用的tomcat的worker线程池，这个worker线程池的上限是3000，SO。。。这种隐藏的问题影响所有使用到HeapByteBuffer的地方而且很隐秘，在类似我们这种文件服务的大sizeIO且调用线程比较多的场景下容易暴露出来。</p>
<hr>
<p>获取临时DirectByteBuffer的逻辑：</p>
<pre tabindex="0"><code>/**
     * Returns a temporary buffer of at least the given size
     */
    public static ByteBuffer getTemporaryDirectBuffer(int size) {
        BufferCache cache = bufferCache.get();
        ByteBuffer buf = cache.get(size);
        if (buf != null) {
            return buf;
        } else {
            // No suitable buffer in the cache so we need to allocate a new
            // one. To avoid the cache growing then we remove the first
            // buffer from the cache and free it.
            if (!cache.isEmpty()) {
                buf = cache.removeFirst();
                free(buf);
            }
            return ByteBuffer.allocateDirect(size);
        }
    }
</code></pre><p>bufferCache从ByteBuffer数组里选取合适的ByteBuffer:</p>
<pre tabindex="0"><code> /**
         * Removes and returns a buffer from the cache of at least the given
         * size (or null if no suitable buffer is found).
         */
        ByteBuffer get(int size) {
            if (count == 0)
                return null;  // cache is empty

            ByteBuffer[] buffers = this.buffers;

            // search for suitable buffer (often the first buffer will do)
            ByteBuffer buf = buffers[start];
            if (buf.capacity() &lt; size) {
                buf = null;
                int i = start;
                while ((i = next(i)) != start) {
                    ByteBuffer bb = buffers[i];
                    if (bb == null)
                        break;
                    if (bb.capacity() &gt;= size) {
                        buf = bb;
                        break;
                    }
                }
                if (buf == null)
                    return null;
                // move first element to here to avoid re-packing
                buffers[i] = buffers[start];
            }

            // remove first element
            buffers[start] = null;
            start = next(start);
            count--;

            // prepare the buffer and return it
            buf.rewind();
            buf.limit(size);
            return buf;
        }
</code></pre><p>将ByteBuffer回种到bufferCache:</p>
<pre tabindex="0"><code>/**
     * Releases a temporary buffer by returning to the cache or freeing it. If
     * returning to the cache then insert it at the start so that it is
     * likely to be returned by a subsequent call to getTemporaryDirectBuffer.
     */
    static void offerFirstTemporaryDirectBuffer(ByteBuffer buf) {
        assert buf != null;
        BufferCache cache = bufferCache.get();
        if (!cache.offerFirst(buf)) {
            // cache is full
            free(buf);
        }
    }
</code></pre><h3 id="分析结论">分析结论</h3>
<p><em><!-- raw HTML omitted -->NIO中的FileChannel、SocketChannel等Channel默认在通过IOUtil进行IO读写操作时，除了会使用HeapByteBuffer作为和应用程序的对接缓冲，但在底层还会使用一个临时的DirectByteBuffer来和系统进行真正的IO交互，为提高性能，当使用完后这个临时的DirectByteBuffer会被存放到ThreadLocal的缓存中不会释放，当直接使用HeapByteBuffer的线程数较多或者IO操作的size较大时，会导致这些临时的DirectByteBuffer占用大量堆外内存造成泄露。<!-- raw HTML omitted --></em></p>
<p><em>那么除了减少直接调用ehcache读写的线程数有没有其他办法能解决这个问题？并发比较高的场景下一味减少业务线程数不是一个好办法。答案是有的！</em></p>
<p><em><!-- raw HTML omitted -->在Java1.8_102版本开始，官方提供一个参数jdk.nio.maxCachedBufferSize，这个参数用于限制可以被缓存的DirectByteBuffer的大小，对于超过这个限制的DirectByteBuffer不会被缓存到ThreadLocal的bufferCache中，这样就能被GC正常回收掉。唯一的tradeoff是读写的性能会稍差一些，毕竟创建一个新的DirectByteBuffer的代价也不小，当然如上面列出的，性能也没有数量级的差别。我们业务就是调整了-Djdk.nio.maxCachedBufferSize=500000（注意这里是字节数，不能用m、k、g）之后，运行几天整体DirectByteBuffer稳定控制在300m左右，性能也几乎没有衰减。<!-- raw HTML omitted --></em></p>
<p><em>搞定收工 ！</em></p>
<hr>
<p>参考：
<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr022.html">NMT使用介绍</a>
<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/378acd4d03c8/">open jdk</a>
<a href="http://hongjiang.info/java-referencequeue/">话说ReferenceQueue</a>
<a href="http://normanmaurer.me/presentations/2014-eclipsecon-na-netty/slides.html#10.0">池化、非池化、堆内、堆外四种ByteBuffer性能比对</a>
<a href="https://www.oracle.com/technetwork/java/javase/8u102-relnotes-3021767.html">java8u102 release note</a>
<a href="http://www.evanjones.ca/java-bytebuffer-leak.html">Fixing Java&rsquo;s ByteBuffer native memory &ldquo;leak&rdquo;</a></p>
</div>

  <footer class="article-footer">
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">CATEGORIES</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="https://coldwalker.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    <section class="bordered">
      <header>
        <div class="panel-title">TAGS</div>
      </header>
      <div>
        <ul class="p-terms">
          
          <li><a href="https://coldwalker.github.io/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">问题排查</a></li>
          
          <li><a href="https://coldwalker.github.io/tags/java/">Java</a></li>
          
          <li><a href="https://coldwalker.github.io/tags/jvm/">JVM</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>

    
      
      <div id="cyReward" role="cylabs" data-use="reward"></div>
      <script src="//changyan.itc.cn/js/lib/jquery.js"></script>
      <script src="//changyan.sohu.com/js/changyan.labs.https.js?appid=cytwFfxww"></script>
      <div id="SOHUCS" sid="https://coldwalker.github.io/2018/12/troubleshooter_directbytebuffer_memory_issue/" ></div>
      <script>
      (function(){
      var appid = 'cytwFfxww';
      var conf = 'prod_36cf3e358f9305067d10b0652031cb07';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('\x3Cscript id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>
      
    

   
  </div>

  <div class="col-md-3">
    
<aside class="l-sidebar">

  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="https://coldwalker.github.io/2024/05/mtu_probe_details/" class="list-group-item">关于MTU探测的一些细节</a>
      
      <a href="https://coldwalker.github.io/2020/01/log4j-thread-blocked-issue/" class="list-group-item">记log4j打印异常日志导致线程阻塞的问题排查</a>
      
      <a href="https://coldwalker.github.io/2019/02/gc_problem_resolve/" class="list-group-item">Java垃圾回收浅析(4)-GC常见问题分析</a>
      
      <a href="https://coldwalker.github.io/2019/02/gc_log_analyze/" class="list-group-item">Java垃圾回收浅析(3)-GC日志分析</a>
      
      <a href="https://coldwalker.github.io/2019/02/gc_intro/" class="list-group-item">Java垃圾回收浅析(2)-GC方式介绍</a>
      
      <a href="https://coldwalker.github.io/2019/02/gc_object_alloc_process/" class="list-group-item">Java垃圾回收浅析(1)-对象内存申请</a>
      
      <a href="https://coldwalker.github.io/2018/12/troubleshooter_directbytebuffer_memory_issue/" class="list-group-item">DirectByteBuffer堆外内存溢出问题排查</a>
      
      <a href="https://coldwalker.github.io/2018/08/troubleshooter_native_memory_increase/" class="list-group-item">Java堆外内存增长问题排查Case</a>
      
      <a href="https://coldwalker.github.io/2018/03/troubleshooter_stackoverflowerror/" class="list-group-item">StackOverFlowError问题引出的JVM栈内存管理</a>
      
      <a href="https://coldwalker.github.io/2018/03/robust-service_hystrix/" class="list-group-item">服务稳定性提升之-熔断组件Hystrix</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      
      <div class="panel-title">CATEGORY</div>
    </div>
    <div class="list-group">
      
      <a href="https://coldwalker.github.io/categories/%E6%8A%80%E6%9C%AF" class="list-group-item">技术(11)</a>
      
      <a href="https://coldwalker.github.io/categories/%E6%84%9F%E6%82%9F" class="list-group-item">感悟(1)</a>
      
      <a href="https://coldwalker.github.io/categories/%E7%94%9F%E6%B4%BB" class="list-group-item">生活(1)</a>
      
    </div>
  </section>
  
  <section class="panel panel-default">
    <div class="panel-heading">
      
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      <a href="https://coldwalker.github.io/tags/java" class="list-group-item">Java(10)</a>
      
      <a href="https://coldwalker.github.io/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5" class="list-group-item">问题排查(5)</a>
      
      <a href="https://coldwalker.github.io/tags/gc" class="list-group-item">Gc(4)</a>
      
      <a href="https://coldwalker.github.io/tags/jvm" class="list-group-item">Jvm(3)</a>
      
      <a href="https://coldwalker.github.io/tags/netflix" class="list-group-item">Netflix(1)</a>
      
      <a href="https://coldwalker.github.io/tags/%E5%86%85%E6%A0%B8" class="list-group-item">内核(1)</a>
      
      <a href="https://coldwalker.github.io/tags/%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6" class="list-group-item">开源组件(1)</a>
      
      <a href="https://coldwalker.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%A8%B3%E5%AE%9A%E6%80%A7" class="list-group-item">服务稳定性(1)</a>
      
      <a href="https://coldwalker.github.io/tags/%E7%BD%91%E7%BB%9C" class="list-group-item">网络(1)</a>
      
    </div>
  </section>
  
 
  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">Archive</div>
    </div>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2024-05" class="list-group-item">2024-05(2)</a>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2020-01" class="list-group-item">2020-01(1)</a>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2019-02" class="list-group-item">2019-02(4)</a>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2018-12" class="list-group-item">2018-12(1)</a>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2018-08" class="list-group-item">2018-08(1)</a>
    
      
    <div class="list-group">
      <a href="https://coldwalker.github.io/post/#2018-03" class="list-group-item">2018-03(4)</a>
    
    </div>
  </section>
  
</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you wish to quote or reproduce.</p>
        
      </div>
    </footer>

    <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

